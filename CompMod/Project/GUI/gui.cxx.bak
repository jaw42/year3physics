// generated by Fast Light User Interface Designer (fluid) version 1.0301

#include "gui.h"
#include <iostream>
#include <stdio.h>
#include <iomanip>
using namespace std;

Fl_Double_Window *win=(Fl_Double_Window *)0;

Fl_Button *animate=(Fl_Button *)0;

static void cb_animate(Fl_Button*, void*) {
  cout << "Animate" << endl;
}

Fl_Button *Calculate=(Fl_Button *)0;

static void cb_Calculate(Fl_Button*, void*) {
  cout << "calculate" << endl;
}

Fl_Button *calcani=(Fl_Button *)0;

static void cb_calcani(Fl_Button*, void*) {
  cout << "calc ani" << endl;
}

Fl_Value_Slider *startcord_in=(Fl_Value_Slider *)0;

static void cb_startcord_in(Fl_Value_Slider*, void*) {
  cout << "Other" << endl;
}

Fl_Value_Slider *maxTime_in=(Fl_Value_Slider *)0;

static void cb_maxTime_in(Fl_Value_Slider*, void*) {
  cout << "This" << endl;
}

Fl_Choice *seedfunction=(Fl_Choice *)0;

static void cb_seedfunction(Fl_Choice*, void*) {
  cout << "function" << endl;
}

Fl_Menu_Item menu_seedfunction[] = {
 {"Guassian", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Sine", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Cosine", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

Fl_Choice *systemtype=(Fl_Choice *)0;

static void cb_systemtype(Fl_Choice*, void*) {
  cout << "system" << endl;
}

Fl_Menu_Item menu_systemtype[] = {
 {"Bounded", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Infinite", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Absorbing", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

Fl_Check_Button *dielectric=(Fl_Check_Button *)0;

static void cb_dielectric(Fl_Check_Button*, void*) {
  cout << "radio" << endl;
}

Fl_Progress *progressbar=(Fl_Progress *)0;

Fl_Button *killgnu=(Fl_Button *)0;

static void cb_killgnu(Fl_Button*, void*) {
  cout << "Kill" << endl;
}

Fl_Button *deletefiles=(Fl_Button *)0;

static void cb_deletefiles(Fl_Button*, void*) {
  cout << "delete" << endl;
}

Fl_Button *close=(Fl_Button *)0;

static void cb_close(Fl_Button*, void*) {
  cout << "close" << endl;
}

Fl_Check_Button *d3=(Fl_Check_Button *)0;

Fl_Value_Slider *dielectricleft=(Fl_Value_Slider *)0;

static void cb_dielectricleft(Fl_Value_Slider*, void*) {
  cout << "width" << endl;
}

Fl_Value_Slider *dielectricright=(Fl_Value_Slider *)0;

static void cb_dielectricright(Fl_Value_Slider*, void*) {
  cout << "width" << endl;
}

Fl_Counter *lossvalue=(Fl_Counter *)0;

static void cb_lossvalue(Fl_Counter*, void*) {
  cout << "lossvalue" << endl;
}

Fl_Counter *permvalue=(Fl_Counter *)0;

static void cb_permvalue(Fl_Counter*, void*) {
  cout << "permvalue" << endl;
}

Fl_Check_Button *TFSF=(Fl_Check_Button *)0;

int main(int argc, char **argv) {
  { win = new Fl_Double_Window(605, 425, "FDTD");
    { animate = new Fl_Button(80, 304, 100, 30, "Animate");
      animate->callback((Fl_Callback*)cb_animate);
    } // Fl_Button* animate
    { Calculate = new Fl_Button(249, 304, 100, 30, "Calculate");
      Calculate->callback((Fl_Callback*)cb_Calculate);
    } // Fl_Button* Calculate
    { calcani = new Fl_Button(420, 304, 100, 30, "Calc + Ani");
      calcani->callback((Fl_Callback*)cb_calcani);
    } // Fl_Button* calcani
    { startcord_in = new Fl_Value_Slider(150, 20, 300, 30, "Seed Co-Ordinate");
      startcord_in->type(1);
      startcord_in->maximum(200);
      startcord_in->step(10);
      startcord_in->value(50);
      startcord_in->textsize(14);
      startcord_in->callback((Fl_Callback*)cb_startcord_in);
      startcord_in->align(Fl_Align(FL_ALIGN_LEFT));
      startcord_in->when(FL_WHEN_RELEASE);
    } // Fl_Value_Slider* startcord_in
    { maxTime_in = new Fl_Value_Slider(150, 60, 300, 30, "Number of Iterations");
      maxTime_in->type(1);
      maxTime_in->maximum(5000);
      maxTime_in->step(100);
      maxTime_in->value(500);
      maxTime_in->slider_size(0.01);
      maxTime_in->textsize(14);
      maxTime_in->callback((Fl_Callback*)cb_maxTime_in);
      maxTime_in->align(Fl_Align(FL_ALIGN_LEFT));
      maxTime_in->when(FL_WHEN_RELEASE);
    } // Fl_Value_Slider* maxTime_in
    { seedfunction = new Fl_Choice(150, 100, 215, 30, "Seed Function");
      seedfunction->down_box(FL_BORDER_BOX);
      seedfunction->callback((Fl_Callback*)cb_seedfunction);
      seedfunction->menu(menu_seedfunction);
    } // Fl_Choice* seedfunction
    { systemtype = new Fl_Choice(150, 140, 215, 30, "System Type");
      systemtype->down_box(FL_BORDER_BOX);
      systemtype->callback((Fl_Callback*)cb_systemtype);
      systemtype->menu(menu_systemtype);
    } // Fl_Choice* systemtype
    { dielectric = new Fl_Check_Button(150, 180, 20, 30, "Dielectric");
      dielectric->down_box(FL_DOWN_BOX);
      dielectric->callback((Fl_Callback*)cb_dielectric);
      dielectric->align(Fl_Align(FL_ALIGN_LEFT));
    } // Fl_Check_Button* dielectric
    { progressbar = new Fl_Progress(80, 353, 440, 20, "Graphing...");
    } // Fl_Progress* progressbar
    { killgnu = new Fl_Button(500, 223, 85, 20, "Kill GNUPlot");
      killgnu->box(FL_THIN_UP_BOX);
      killgnu->labelsize(10);
      killgnu->callback((Fl_Callback*)cb_killgnu);
    } // Fl_Button* killgnu
    { deletefiles = new Fl_Button(500, 248, 85, 20, "Delete Files");
      deletefiles->box(FL_THIN_UP_BOX);
      deletefiles->labelsize(10);
      deletefiles->callback((Fl_Callback*)cb_deletefiles);
    } // Fl_Button* deletefiles
    { close = new Fl_Button(495, 380, 100, 30, "Close");
      close->callback((Fl_Callback*)cb_close);
    } // Fl_Button* close
    { d3 = new Fl_Check_Button(234, 180, 20, 30, "3D Plot");
      d3->down_box(FL_DOWN_BOX);
      d3->align(Fl_Align(FL_ALIGN_LEFT));
    } // Fl_Check_Button* d3
    { dielectricleft = new Fl_Value_Slider(75, 213, 205, 30, "Dielectric Left");
      dielectricleft->type(1);
      dielectricleft->maximum(200);
      dielectricleft->step(10);
      dielectricleft->value(100);
      dielectricleft->textsize(14);
      dielectricleft->callback((Fl_Callback*)cb_dielectricleft);
      dielectricleft->when(FL_WHEN_RELEASE);
    } // Fl_Value_Slider* dielectricleft
    { dielectricright = new Fl_Value_Slider(285, 213, 205, 30, "Dielectric Right");
      dielectricright->type(1);
      dielectricright->maximum(200);
      dielectricright->step(10);
      dielectricright->value(100);
      dielectricright->textsize(14);
      dielectricright->callback((Fl_Callback*)cb_dielectricright);
      dielectricright->when(FL_WHEN_RELEASE);
    } // Fl_Value_Slider* dielectricright
    { lossvalue = new Fl_Counter(150, 265, 140, 20, "Lossy Material");
      lossvalue->tooltip("Set to 0 for a lossless material");
      lossvalue->minimum(0);
      lossvalue->maximum(1);
      lossvalue->step(0.01);
      lossvalue->value(0.8);
      lossvalue->callback((Fl_Callback*)cb_lossvalue);
      lossvalue->align(Fl_Align(FL_ALIGN_LEFT));
      lossvalue->when(FL_WHEN_RELEASE);
    } // Fl_Counter* lossvalue
    { permvalue = new Fl_Counter(390, 265, 100, 20, "Permittivity");
      permvalue->tooltip("Relative permittivity of the lossy dielectric");
      permvalue->minimum(0);
      permvalue->maximum(20);
      permvalue->step(0.5);
      permvalue->value(0.8);
      permvalue->callback((Fl_Callback*)cb_permvalue);
      permvalue->align(Fl_Align(FL_ALIGN_LEFT));
      permvalue->when(FL_WHEN_RELEASE);
    } // Fl_Counter* permvalue
    { TFSF = new Fl_Check_Button(306, 180, 20, 30, "TFSF");
      TFSF->tooltip("Use a Total Field/Scattered Feild boundary as the source");
      TFSF->down_box(FL_DOWN_BOX);
      TFSF->align(Fl_Align(FL_ALIGN_LEFT));
    } // Fl_Check_Button* TFSF
    win->end();
  } // Fl_Double_Window* win
  win->show(argc, argv);
  return Fl::run();
}
